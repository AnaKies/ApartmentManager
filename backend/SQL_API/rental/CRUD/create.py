from ApartmentManager.backend.SQL_API.rental.rental_orm_models import Session, PersonalData, Apartment, Tenancy, Contract
from ApartmentManager.backend.AI_API.general.error_texts import ErrorCode, APIError
from ApartmentManager.backend.AI_API.general.logger import log_error

def create_person(first_name: str,
                    last_name: str,
                    bank_data: str,
                    phone_number: str,
                    email: str,
                    comment: str) -> dict:
    """
    Creates a new entry for a person in the database. The function gathers
    information about a person, validates the essential parameters, and
    stores the data in the database. If successful, it returns a dictionary
    containing a success indicator and stored attributes like `person_id`,
    `first_name`, and `last_name`.
    """
    session = None
    try:
        session = Session()

        person = PersonalData(
            first_name = first_name,
            last_name = last_name,
            bank_data = bank_data,
            phone_number = phone_number,
            email = email,
            comment = comment)

        required_params = first_name not in (None, "") and last_name not in (None, "")

        if not required_params:
            raise APIError(ErrorCode.SQL_PARAMETER_ERROR_CREATING_NEW_PERSON)

        session.add(person)

        # Flush sends INSERT to DB and populates autogenerated primary key
        session.flush()

        # save the data of the person, that will be deleted in the next step
        person_data = person.to_dict()

        session.commit()

        return person_data

    except APIError:
        if session:
            session.rollback()
        raise
    except Exception as error:
        if session:
            session.rollback()
        trace_id = log_error(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_PERSON, error)
        raise APIError(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_PERSON, trace_id) from error
    finally:
        if session:
            session.close()


    """
    personal_data = [
        PersonalData(first_name="Maria", last_name="Schmid", bank_data="DE3567", phone_number="+495438", email="schmid@mail.de", comment="Betreuung"),
        PersonalData(first_name="Lukas", last_name="Müller", bank_data="DE1234", phone_number="+491234567", email="lukas.mueller@mail.de", comment="Neue Mieter"),
        PersonalData(first_name="Anna", last_name="Weber", bank_data="DE5678", phone_number="+492345678", email="anna.weber@mail.de", comment="Zahlung ausstehend"),
        PersonalData(first_name="Jonas", last_name="Schneider", bank_data="DE9101", phone_number="+493456789", email="jonas.schneider@mail.de", comment="Schlüssel abgegeben"),
        PersonalData(first_name="Sophie", last_name="Fischer", bank_data="DE1121", phone_number="+494567890", email="sophie.fischer@mail.de", comment="Vertragsverlängerung"),
        PersonalData(first_name="Max", last_name="Becker", bank_data="DE3141", phone_number="+495678901", email="max.becker@mail.de", comment="Einzug geplant")
    ]
    session.add_all(personal_data)


    res = create_person(first_name="Olga" ,
                    last_name="Ivanova",
                    bank_data="RU34567",
                    phone_number="+7235890",
                    email="olga.ivanova@mail.ru",
                    comment="new tenant from oktober")
    """

def create_apartment(area: float,
                     address: str,
                     price_per_square_meter: float,
                     utility_billing_provider_id: int) -> dict:
    session = None
    try:
        session = Session()

        apartment = Apartment(
            area=area,
            address=address,
            price_per_square_meter=price_per_square_meter,
            utility_billing_provider_id=utility_billing_provider_id
        )

        required_params = address not in (None, "")

        if not required_params:
            raise APIError(ErrorCode.SQL_PARAMETER_ERROR_CREATING_NEW_APARTMENT) # Assuming this error code exists or I should use a generic one

        session.add(apartment)
        session.flush()
        apartment_data = apartment.to_dict()
        session.commit()

        return apartment_data

    except APIError:
        if session:
            session.rollback()
        raise
    except Exception as error:
        if session:
            session.rollback()
        trace_id = log_error(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_APARTMENT, error) # Assuming error code
        raise APIError(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_APARTMENT, trace_id) from error
    finally:
        if session:
            session.close()

def create_tenancy(id_apartment: int,
                   id_tenant_personal_data: int,
                   id_contract: int,
                   move_in_date: str,
                   move_out_date: str,
                   deposit: float,
                   registered_address: str,
                   comment: str) -> dict:
    session = None
    try:
        session = Session()

        tenancy = Tenancy(
            id_apartment=id_apartment,
            id_tenant_personal_data=id_tenant_personal_data,
            id_contract=id_contract,
            move_in_date=move_in_date,
            move_out_date=move_out_date,
            deposit=deposit,
            registered_address=registered_address,
            comment=comment
        )

        required_params = move_in_date not in (None, "")

        if not required_params:
            raise APIError(ErrorCode.SQL_PARAMETER_ERROR_CREATING_NEW_TENANCY)

        session.add(tenancy)
        session.flush()
        tenancy_data = tenancy.to_dict()
        session.commit()

        return tenancy_data

    except APIError:
        if session:
            session.rollback()
        raise
    except Exception as error:
        if session:
            session.rollback()
        trace_id = log_error(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_TENANCY, error)
        raise APIError(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_TENANCY, trace_id) from error
    finally:
        if session:
            session.close()

def create_contract(net_rent: float,
                    utility_costs: float,
                    vat: float,
                    garage: float,
                    parking_spot: float,
                    comment: str) -> dict:
    session = None
    try:
        session = Session()

        contract = Contract(
            net_rent=net_rent,
            utility_costs=utility_costs,
            vat=vat,
            garage=garage,
            parking_spot=parking_spot,
            comment=comment
        )

        required_params = net_rent not in (None, "")

        if not required_params:
            raise APIError(ErrorCode.SQL_PARAMETER_ERROR_CREATING_NEW_CONTRACT)

        session.add(contract)
        session.flush()
        contract_data = contract.to_dict()
        session.commit()

        return contract_data

    except APIError:
        if session:
            session.rollback()
        raise
    except Exception as error:
        if session:
            session.rollback()
        trace_id = log_error(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_CONTRACT, error)
        raise APIError(ErrorCode.SQL_ERROR_CREATING_ENTRY_FOR_NEW_CONTRACT, trace_id) from error
    finally:
        if session:
            session.close()